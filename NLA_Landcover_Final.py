# -*- coding: utf-8 -*-

# Import modules
import arcpy, os, numpy, shutil
from arcpy import env
from numpy import *
from arcpy.sa import *
arcpy.CheckOutExtension("spatial")



##########################################################################################
##################################   AVANT DE DÉBUTER  ###################################
##########################################################################################

# ASSUREZ VOUS QUE LES MATRICES D'UTILISATION DES TERRES SOIENT BIEN LOCALISÉES DANS DES
# DOSSIERS PROPREMENT NOMMÉS. LES MATRICES HISTORIQUES DOIVENT ÊTRE LOCALISÉES DANS UN
# DOSSIER NOMMÉ 'CONNUS_Landcover_Historical' ET LES MATRICES DE PROJECTION DOIVENT ÊTRE
# LOCALISÉES DANS UN DOSSIER ASSOCIÉ AU SCÉNARIO UTILISÉ, PAR EXEMPLE :
# 'CONUS_Landcover_A1B'. TOUS CES DOSSIERS DOIVENT ÊTRE LOCALISÉS DANS LE DOSSIER
# D'INTRANTS, SOIT CELUI INDIQUÉ À LA VARIABLE 'inputWS'. ASSUREZ-VOUS ÉGALEMENT QUE LES
# FICHIERS DE LACS ET DE BASSINS VERSANTS CONTIENNENT UN NOMBRE ÉGAL D'ENTRÉES ET QUE
# TOUTES SOIENT JOIGNABLES PAR UN IDENTIFIANT COMMUN. VOUS DEVEZ ÉGALEMENT SUPPRIMER
# TOUS LES BASSINS VESANTS DE MOINS DE 65,000 M2 AINSI QUE LES LACS ASSOCIÉS.

##########################################################################################
###############      DESCRIPTION DE LA TABLE D'ATTRIBUTS EN SORTIE #######################
##########################################################################################

# VALUE_0  : Superficie (m2) des cellules 'NoData'
# VALUE_1  : Superficie (m2) des cellules 'Water'
# VALUE_2  : Superficie (m2) des cellules 'Developed'
# VALUE_3  : Superficie (m2) des cellules 'Mechanically Disturbed National Forests'
# VALUE_4  : Superficie (m2) des cellules 'Mechanically Disturbed Other Public Lands'
# VALUE_5  : Superficie (m2) des cellules 'Mechanically Disturbed Private'
# VALUE_6  : Superficie (m2) des cellules 'Mining'
# VALUE_7  : Superficie (m2) des cellules 'Barren'
# VALUE_8  : Superficie (m2) des cellules 'Deciduous Forest'
# VALUE_9  : Superficie (m2) des cellules 'Evergreen Forest'
# VALUE_10 : Superficie (m2) des cellules 'Mixed Forest'
# VALUE_11 : Superficie (m2) des cellules 'Grassland'
# VALUE_12 : Superficie (m2) des cellules 'Shrubland'
# VALUE_13 : Superficie (m2) des cellules 'Cropland'
# VALUE_14 : Superficie (m2) des cellules 'Hay/Pasture Land'
# VALUE_15 : Superficie (m2) des cellules 'Herbaceous Wetland'
# VALUE_16 : Superficie (m2) des cellules 'Woody Wetland'
# VALUE_17 : Superficie (m2) des cellules 'Perennial Ice/Snow'
# VALUE_18 : Superficie (m2) des cellules 'Water' à l'intérieur des polygones de lac

# VALUE_0_p  : Pourcentage (%) du BV ne contenant pas de données (cette portion n'est pas incluse dans les pourcentages suivants)
# VALUE_1_p  : Pourcentage (%) du bassin versant occupé par 'Water'
# VALUE_2_p  : Pourcentage (%) du bassin versant occupé par 'Developed'
# VALUE_3_p  : Pourcentage (%) du bassin versant occupé par 'Mechanically Disturbed National Forests'
# VALUE_4_p  : Pourcentage (%) du bassin versant occupé par 'Mechanically Disturbed Other Public Lands'
# VALUE_5_p  : Pourcentage (%) du bassin versant occupé par 'Mechanically Disturbed Private'
# VALUE_6_p  : Pourcentage (%) du bassin versant occupé par 'Mining'
# VALUE_7_p  : Pourcentage (%) du bassin versant occupé par 'Barren'
# VALUE_8_p  : Pourcentage (%) du bassin versant occupé par 'Deciduous Forest'
# VALUE_9_p  : Pourcentage (%) du bassin versant occupé par 'Evergreen Forest'
# VALUE_10_p : Pourcentage (%) du bassin versant occupé par 'Mixed Forest'
# VALUE_11_p : Pourcentage (%) du bassin versant occupé par 'Grassland'
# VALUE_12_p : Pourcentage (%) du bassin versant occupé par 'Shrubland'
# VALUE_13_p : Pourcentage (%) du bassin versant occupé par 'Cropland'
# VALUE_14_p : Pourcentage (%) du bassin versant occupé par 'Hay/Pasture Land'
# VALUE_15_p : Pourcentage (%) du bassin versant occupé par 'Herbaceous Wetland'
# VALUE_16_p : Pourcentage (%) du bassin versant occupé par 'Woody Wetland'
# VALUE_17_p : Pourcentage (%) du bassin versant occupé par 'Perennial Ice/Snow'

##########################################################################################
#############################   PARAMÈTRES D'UTILISATEUR   ###############################
##########################################################################################

trashWS = "C:\\GIS\\ReseauLab\\Nico\\Trash\\"           #Entrez le chemin d'accès des données sortantes intermédiaires
outputWS = "C:\GIS\ReseauLab\Nico\\Code_Output\\"       #Entrez le chemin d'accès des données sortantes
inputWS = "C:\GIS\ReseauLab\Nico\\"                     #Entrez le chemin d'accès des données en intrant

proYears = ["2025", "2050", "2075", "2100"]             #Entrez les années de projection de l'utilisation des sols désirées
histYears = ["2005"]                                    #Entrez les années historiques d'utilisation des sols désirées
scenario = ["A1B"]                                      #Entrez les scénarios désirés

catchments = inputWS + os.sep + "Catchments_All.shp"    #Entrez le nom de votre shapefile des bassins versants (en vert)
lakes = inputWS + os.sep + "Lakes_All.shp"              #Entrez le nom de votre shapefile des lacs (en vert)
idField = "NLA_ID"                                      #Entrez le nom du champ d'identification commun entre les deux fichiers (doit être le même pour les deux)

##########################################################################################
##########################################################################################
##########################################################################################



###########################
# Gestion du dossier Output
###########################

if os.path.exists(outputWS):
    print "-"
    print "*****  ATTENTION!   ATTENTION!   ATTENTION!   ATTENTION!  *****"
    print "***** Vous vous appretez a supprimer la totalite du       *****"
    print "***** contenu du dossier 'Output'. Cette operation permet *****"
    print "***** de reduire considerablement les temps de calcul.    *****"
    print "-"
    reponse = raw_input("Tapez 'Y' pour continuer ou 'N' pour passer directement a l'etape suivante, puis validez avec 'Entree'.").lower()
    if reponse == "Y" or reponse == "y":
        shutil.rmtree(outputWS)
        os.makedirs(outputWS)
        print "Le contenu du dossier 'Output' a ete supprime avec succes"
else:
    os.makedirs(outputWS)
    print "Le dossier 'Output' a ete cree avec succes"



##########################
# Gestion du dossier Trash
##########################
    
if os.path.exists(trashWS):
    print "-"
    print "*****  ATTENTION!   ATTENTION!   ATTENTION!   ATTENTION!  *****"
    print "***** Vous vous appretez a supprimer la totalite du       *****"
    print "***** contenu du dossier 'Trash'. Cette operation permet  *****"
    print "***** de reduire considerablement les temps de calcul.    *****"
    print "-"
    reponse = raw_input("Tapez 'Y' pour continuer ou 'N' pour passer directement a l'etape suivante, puis validez avec 'Entree'.").lower()
    if reponse == "Y" or reponse == "y":
        shutil.rmtree(trashWS)
        os.makedirs(trashWS)
        print "Le contenu du dossier 'Trash' a ete supprime avec succes"
else:
    os.makedirs(trashWS)
    print "Le dossier 'Trash' a ete cree avec succes"

    

########################################################################
# Définition du dossier de travail et activation du statut de réécriture
########################################################################
    
arcpy.env.workspace = outputWS
arcpy.env.overwriteOutput = True



###################################################
# Importation des matrices d'utilisation des terres
###################################################

print "-"
for item1 in scenario:
    for item2 in proYears:
        inRaster = (inputWS + os.sep + "CONUS_Landcover_" + item1 + os.sep + "CONUS_" + item1 + "_y" + item2 + ".tif")
        outRaster = (trashWS + os.sep + "CONUS_" + item1 + "_y" + item2 + ".tif")
        arcpy.CopyRaster_management (inRaster, outRaster)
        print "La matrice CONUS_" + item1 + "_y" + item2 + ".tif a ete importee avec succes"

for item3 in histYears:           
        inRaster = (inputWS + os.sep + "CONUS_Landcover_Historical" + os.sep + "CONUS_Historical_y" + item3 + ".tif")
        outRaster = (trashWS + os.sep + "CONUS_Historical_y" + item3 + ".tif")
        arcpy.CopyRaster_management (inRaster, outRaster)
        print "La matrice CONUS_Historical_y" + item3 + ".tif a ete importee avec succes"



###########################################################################
# Définition du système de projection des matrices d'utilisation des terres
###########################################################################

arcpy.env.workspace = trashWS
arcpy.env.overwriteOutput = True
rasterList1 = arcpy.ListRasters("*CONUS*", "All")

descMap = rasterList1[0]
desc = arcpy.Describe(descMap)
coordSys = desc.spatialReference
arcpy.env.snapRaster = rasterList1[0]


################################################################################
# Projection des couches de lacs et de bassins versants et création des matrices
################################################################################

prjLakesPoly = (trashWS + os.sep + "Lakes_All_prj.shp")
LakesPolyBuf = (trashWS + os.sep + "Lakes_All_prj_buf.shp")
LakesRaster = (trashWS + os.sep + "Lakes_All_prj.tif")
LakesRec = (trashWS + os.sep + "Lakes_All_prj_zero.tif")
prjCatchmentsPoly = (trashWS + os.sep + "Catchments_All_prj.shp")
CatchmentsRaster = (trashWS + os.sep + "Catchments_All_prj.tif")
CatchmentsRec = (trashWS + os.sep + "Catchments_All_prj_zero.tif")
print "-"

arcpy.Project_management(lakes, prjLakesPoly, coordSys)
arcpy.Project_management(catchments, prjCatchmentsPoly, coordSys)
print "Les couches des lacs et des bassins versants ont ete projetees avec succes"

arcpy.PolygonToRaster_conversion(prjCatchmentsPoly, "FID", CatchmentsRaster, "MAXIMUM_AREA", "NONE", 250)
arcpy.gp.Reclassify_sa(CatchmentsRaster, "VALUE", "0 10000 1; NODATA 0", CatchmentsRec, "DATA")
arcpy.env.extent = CatchmentsRec

arcpy.Buffer_analysis(prjLakesPoly, LakesPolyBuf, 250)
arcpy.PolygonToRaster_conversion(LakesPolyBuf, "FID", LakesRaster, "MAXIMUM_AREA", "NONE", 250)
arcpy.gp.Reclassify_sa(LakesRaster, "VALUE", "0 10000 100; NODATA 1", LakesRec, "DATA")
print "Les couches des lacs et des bassins versants ont ete converties en matrices avec succes"



############################################################################################
# Modification des cellules ne contenant pas d'information sur l'utilisation des terres (=0)
############################################################################################

rasterList1 = arcpy.ListRasters("*CONUS*", "All")
print "-"

x = 0
for lc in rasterList1:
    fileNameExt = os.path.basename(rasterList1[x])
    fileName = os.path.splitext(fileNameExt)
    inRaster = rasterList1[x]
    outRaster = (trashWS + os.sep + fileName[0] + "_rec.tif")

    outCon = Con(IsNull (inRaster), 0, inRaster)
    outCon.save(outRaster)
    print "Les cellules NoData ont ete remplacees par la valeur '0' pour " + fileName[0] + ".tif"
                           
    x = x + 1



###########################################################################
# Modification des cellules d'eau à l'intérieur des polygones de lacs (=18)
###########################################################################

rasterList2 = arcpy.ListRasters("*_rec.tif*", "All")
inRaster1 = (trashWS + os.sep + "Lakes_All_prj_zero.tif")
calculRaster = (trashWS + os.sep + "Calcul.tif")
reclassRaster = (trashWS + os.sep + "Reclass.tif")
print "-"

x = 0
for lc in rasterList2:
    fileNameExt = os.path.basename(rasterList2[x])
    fileName = os.path.splitext(fileNameExt)
    inRaster2 = rasterList2[x]
    outRaster = (trashWS + os.sep + fileName[0] + "_NoLake.tif")

    outCalcul = Times(inRaster1, inRaster2)
    outCalcul.save(calculRaster)
    arcpy.gp.Reclassify_sa(calculRaster, "VALUE", "100 100 18", reclassRaster, "DATA")
    outCon = Con(reclassRaster, inRaster2, reclassRaster, "VALUE >= 100")
    outCon.save(outRaster)

    print "Les cellules d'eau a l'interieur des lacs ont ete remplacees par la valeur '18' pour " + fileName[0] + ".tif"

    x = x + 1


                    

#######################################################################
# Création des tables de superficies des types d'utilisation des terres
#######################################################################

rasterList3 = arcpy.ListRasters("*_rec_NoLake.tif*", "All")
prjCatchmentsPoly = (trashWS + os.sep + "Catchments_All_prj.shp")
arcpy.CreateFileGDB_management(trashWS, "trash.gdb")
trashGDB = (trashWS + os.sep + "trash.gdb")
    
print "-"

x = 0
for lc in rasterList3:
    print "-"
    fileNameExt = os.path.basename(rasterList1[x])
    fileName = os.path.splitext(fileNameExt)

    catchmentsCopy = (trashWS + os.sep + fileName[0] + "_Copy.shp")
    arcpy.CopyFeatures_management(prjCatchmentsPoly, catchmentsCopy)

    prjCatchmentsLayer = (trashWS + os.sep + fileName[0] + "_Copy.lyr")
    arcpy.MakeFeatureLayer_management(catchmentsCopy, prjCatchmentsLayer)
    
    outTable = (fileName[0] + "_Table.dbf")
    outTableTemp = (trashWS + os.sep + fileName[0] + "_temp.dbf")
    arcpy.CreateTable_management(trashWS, outTable, prjCatchmentsLayer)
    
    z = 0
    while z <= 18:
        arcpy.AddField_management(outTable, "VALUE_" + str(z), "DOUBLE")
        z = z + 1
    
    with arcpy.da.SearchCursor(prjCatchmentsLayer, idField) as cursor:
        for row in cursor:
            arcpy.SelectLayerByAttribute_management(prjCatchmentsLayer, 'NEW_SELECTION', idField + "='" + row[0] + "'")
            TabulateArea(prjCatchmentsLayer, idField, rasterList3[x], "VALUE", outTableTemp)
            arcpy.Append_management(outTableTemp, outTable, "NO_TEST")
            print "La ligne " + row[0] + " a ete ajoutee a la table " + fileName[0] + ".dbf"

    catchmentsTemp = (trashWS + os.sep + fileName[0] + ".shp")
    arcpy.AddIndex_management(prjCatchmentsLayer, [idField])
    arcpy.SelectLayerByAttribute_management(prjCatchmentsLayer, 'NEW_SELECTION', "FID >= 0")
    catchmentsJoin = arcpy.JoinField_management(prjCatchmentsLayer, idField, outTable, idField)
    arcpy.CopyFeatures_management(catchmentsJoin, catchmentsTemp)
    print "La table " + fileName[0] + " a ete cree avec succes et associee au shapefile des bassins versants" 
    
    arcpy.FeatureClassToGeodatabase_conversion(catchmentsTemp, trashGDB)
    catchmentsGDB = (trashWS + os.sep + "trash.gdb" + os.sep + fileName[0])

    arcpy.AddField_management(catchmentsGDB, "VALUE_0_p", "DOUBLE")
    arcpy.CalculateField_management(catchmentsGDB, "VALUE_0_p", "(!VALUE_0! * 100) / (!VALUE_0!+!VALUE_1!+!VALUE_2!+!VALUE_3!+!VALUE_4!+!VALUE_5!+!VALUE_6!+!VALUE_7!+!VALUE_8!+!VALUE_9!+!VALUE_10!+!VALUE_11!+ !VALUE_12!+!VALUE_13!+!VALUE_14!+!VALUE_15!+!VALUE_16!+!VALUE_17!+!VALUE_18!)", "PYTHON")

    y = 1
    while y <= 17:
        arcpy.AddField_management(catchmentsGDB, "VALUE_" + str(y) + "_p", "DOUBLE")
        arcpy.CalculateField_management(catchmentsGDB, "VALUE_" + str(y) + "_p", "(!VALUE_" + str(y) + "! * 100) / (!VALUE_1!+!VALUE_2!+!VALUE_3!+!VALUE_4!+!VALUE_5!+!VALUE_6!+!VALUE_7!+!VALUE_8!+!VALUE_9!+!VALUE_10!+!VALUE_11!+!VALUE_12!+!VALUE_13!+!VALUE_14!+!VALUE_15!+!VALUE_16!+!VALUE_17!)", "PYTHON")
        y = y + 1

    arcpy.FeatureClassToShapefile_conversion(catchmentsGDB, outputWS)
    catchmentsFinal = (outputWS + os.sep + fileName[0] + ".shp")
    arcpy.DeleteField_management(catchmentsFinal, [idField + "_1", "Shape_Leng", "Shape_Area", "OID"])
    
    outCSV = (fileName[0] + ".csv")
    arcpy.TableToTable_conversion(catchmentsFinal, outputWS, outCSV)
    
    print "Les fichiers " + fileName[0] + ".shp et " + fileName[0] + ".csv ont ete cree avec succes"
    
    x = x + 1
    
print "----------------------------------------------------"
print "Les operations sont terminees"
print "Le dossier 'Trash' peut etre supprime"
print "Les fichiers sont localises dans le dossier 'Code_Output'"

